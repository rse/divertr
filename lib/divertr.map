{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/divertr.js"],"names":["_tokenizr","require","divertr","input","options","Object","assign","regexDump","regexEnter","regexLeave","verbose","state","location","stack","buffer","null","main","overwrite","lexer","_tokenizr2","default","rule","ctx","match","accept","name","rewindNow","rewindNext","plaintext","before","ignore","finish","tokens","forEach","token","isA","value","undefined","Error","push","length","pop","n","indexOf","splice","expandDiversion","seen","keys","output","el","_typeof","module","exports"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n**  Divertr -- Text Diversion Filter\n**  Copyright (c) 1997-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport Tokenizr from \"tokenizr\"\n\n/*  the API method  */\nconst divertr = (input, options) => {\n    /*  configuration options  */\n    options = Object.assign({}, {\n        regexDump:  /<<([a-zA-Z][a-zA-Z0-9_]*)>>/,              /* dump directive  */\n        regexEnter: /\\.\\.(\\!?)([a-zA-Z][a-zA-Z0-9_]*)(\\!?)>>/,  /* enter directive */\n        regexLeave: /<<((?:[a-zA-Z][a-zA-Z0-9_]*)?)\\.\\./,       /* leave directive */\n        verbose:    false\n    }, options)\n\n    /*  internal processing state   */\n    let state = {\n        location:  \"main\",                                      /* currently active location */\n        stack:     [ \"null\" ],                                  /* stack of remembered locations */\n        buffer:    { \"null\": [], \"main\": [] },                  /* the location buffers */\n        overwrite: {}                                           /* the overwrite flags */\n    }\n\n    /*\n    **   PASS 1: Parse the input data into disjunct location buffers\n    **           Each location buffer contains plain text blocks and\n    **           location pointers.\n    */\n\n    /*  establish the lexical parser  */\n    let lexer = new Tokenizr()\n    lexer.rule(options.regexDump, (ctx, match) => {\n        ctx.accept(\"DUMP\", { name: match[1] })\n    })\n    lexer.rule(options.regexEnter, (ctx, match) => {\n        ctx.accept(\"ENTER\", { name: match[2], rewindNow: match[1] !== \"\", rewindNext: match[3] !== \"\" })\n    })\n    lexer.rule(options.regexLeave, (ctx, match) => {\n        ctx.accept(\"LEAVE\", { name: match[1] })\n    })\n    let plaintext = \"\"\n    lexer.before((ctx, match, rule) => {\n        if (rule.name !== \"plaintext\" && plaintext !== \"\") {\n            ctx.accept(\"PLAINTEXT\", plaintext)\n            plaintext = \"\"\n        }\n    })\n    lexer.rule(/./, (ctx, match) => {\n        plaintext += match[0]\n        ctx.ignore()\n    }, \"plaintext\")\n    lexer.finish((ctx) => {\n        if (plaintext !== \"\")\n            ctx.accept(\"PLAINTEXT\", plaintext)\n    })\n\n    /*  parse the input into tokens  */\n    lexer.input(input)\n    lexer.tokens().forEach((token) => {\n        if (token.isA(\"DUMP\")) {\n            /*  on-the-fly initialize location buffer  */\n            let location = token.value.name\n            if (state.buffer[location] === undefined)\n                state.buffer[location] = []\n\n            /*  sanity check location  */\n            if (state.buffer[state.location] === state.buffer[location])\n                throw new Error(`self-reference of location \"${state.location}\"`)\n\n            /*  insert location pointer into current location  */\n            state.buffer[state.location].push(state.buffer[location])\n        }\n        else if (token.isA(\"ENTER\")) {\n            /*  remember old location on stack  */\n            state.stack.push(state.location)\n\n            /*  determine location and optional qualifies, then enter this location  */\n            state.location = token.value.name\n            let rewindNow  = token.value.rewindNow\n            let rewindNext = token.value.rewindNext\n\n            /*  on-the-fly initialize location buffer  */\n            if (state.buffer[state.location] === undefined)\n                state.buffer[state.location] = []\n\n            /*  is a \"rewind now\" forced by a \"rewind next\" from last time?  */\n            if (state.overwrite[state.location]) {\n                rewindNow = true\n                state.overwrite[state.location] = false\n            }\n\n            /*  remember a \"rewind next\" for next time  */\n            if (rewindNext)\n                state.overwrite[state.location] = true\n\n            /*  execute a \"rewind now\" by clearing the location buffer  */\n            if (rewindNow)\n                while (state.buffer[state.location].length > 0)\n                    state.buffer[state.location].pop()\n        }\n        else if (token.isA(\"LEAVE\")) {\n            /*  sanity check situation  */\n            if (state.stack.length === 0)\n                throw new Error(`cannot leave \"null\" location (already in \"null\" location)`)\n            let location = token.value.name\n            if (location === \"null\")\n                throw new Error(`cannot leave \"null\" location (not allowed at all)`)\n            if (location !== \"\" && location !== state.location) {\n                /*  leave the named location and all locations on the stack above it  */\n                let n = state.stack.indexOf(location)\n                if (n === -1)\n                    throw new Error(`no such entered location \"${location}\"`);\n                state.stack.splice(n)\n                state.location = state.stack.pop()\n            }\n            else\n                /*  leave just the current location  */\n                state.location = state.stack.pop()\n        }\n        else if (token.isA(\"PLAINTEXT\")) {\n            /*  insert plaintext into current location  */\n            state.buffer[state.location].push(token.value)\n        }\n    })\n\n    /*\n    **   PASS 2: Recursively expand the location structure\n    **           by starting from the main location buffer\n    */\n\n    /*  expand a partcicular diversion  */\n    const expandDiversion = (buffer) => {\n        /*  check for recursion by making sure\n            the current location has not already been seen.  */\n        state.stack.forEach((seen) => {\n            if (seen === buffer) {\n                /*  find name of location via location pointer\n                    for human readable warning message  */\n                let name = \"unknown\"\n                Object.keys(state.buffer).forEach((n) => {\n                    if (state.buffer[n] === buffer)\n                        name = n\n                })\n                throw new Error(`recursion through location \"${name}\"`)\n            }\n        })\n\n        /*  ok, location still not seen,\n            but remember it for recursive calls.  */\n        state.stack.push(buffer)\n\n        /*  recursively expand the location\n            by stepping through its list elements  */\n        let output = \"\"\n        buffer.forEach((el) => {\n            if (typeof el === \"object\")\n                /*  element is a location pointer, so\n                    recurse into the expansion of it  */\n                output += expandDiversion(el)  /*  RECURSION  */\n            else\n                /*  element is just a plain text block  */\n                output += el\n        })\n\n        /*  we can remove the location from\n            the stack because we are back from recursive calls.  */\n        state.stack.pop()\n\n        /*  return expanded buffer output  */\n        return output\n    }\n\n    /*  recursively expand the diversions in the main buffer  */\n    state.stack = []\n    let output = expandDiversion(state.buffer.main)\n    return output\n}\n\n/*  export API method  */\nmodule.exports = divertr\n\n"]}